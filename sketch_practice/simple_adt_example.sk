adt node{
      Name{ int id; }
      Num{ int val; }
      Plus {node left; node right;}
      Mod {node left; node right;}
      Div {node left; node right;}
      NotEq {node left; node right;}
      Call {int id; node param;}
      If {node test; node then; node orelse;}
      Return {node retval;}
      FunctionDef {int id; Name arg; node stmt;}
 }

 //assume FunctionDef is parsed beforehand and the info is stored in node[m] functions
 int interpret([int n, int m], node e, int[n] assign, FunctionDef[m] functions){
      switch(e){
          case Name: return assign[e.id];
          case Num: return e.val;
          case Plus: return interpret(e.left,assign,functions) + interpret(e.right,assign,functions);
          case Mod: return interpret(e.left,assign,functions) % interpret(e.right,assign,functions);

          case Div: return interpret(e.left, assign,functions) / interpret(e.right, assign,functions);
          case NotEq: return interpret(e.left, assign,functions) != interpret(e.right, assign,functions);
          case If: {
                if(interpret(e.test,assign,functions) == 1){
                    return interpret(e.then,assign,functions);
                }
                else{
                    return interpret(e.orelse,assign,functions);
                }
          }
          case Return: return interpret(e.retval,assign,functions);
          case Call: {
               int paramval = interpret(e.param,assign,functions);
               assign[functions[e.id].arg.id] = paramval;
               return interpret(functions[e.id].stmt,assign,functions);
          }
          case FunctionDef: {
               functions[e.id] = e;
               return interpret(e.stmt,assign,functions);
          }
      }
      assert false;
 }


 void foo(int x);

 harness void main (){
   node e = new FunctionDef(id=0,arg = new Name(id=0), stmt = new If(
              test=new NotEq(left=new Div(left=new Name(id = 0),right=new Num(val=10)),right=new Num(val=0)),
              then=new Return(retval=new Plus(left=new Mod(left=new Name(id=0),right=new Num(val=10)),right=new Call(id=0,param=new Div(left=new Name(id=0),right=new Num(val=10))))),
              orelse=new Return(retval=new Name(id=0))
            )
          );
   int[1] assign = {132};
   FunctionDef[1] functions;
   int ival = interpret(e,assign,functions);
   foo(ival);
 }

/*int size(expr e){
     switch(e){
         case Var: return 1;
         case And: return size(e.left)+ size(e.right) + 1;
         case Or: return size(e.left)+ size(e.right) + 1;
         case Not: return  size(e.left)+1;
         case Const: return 1;
     }
     return 0;
}


void foo(expr e){}

harness void main(int[10] randomness){
     expr t2 = ??(3, {});
     int idx =0;
     expr t3 = ndprog(idx, randomness);
     bit[4] in1 = ??;
     bit[4] in2 = ??;
     assert in1 != in2;
     bit eq1 = interpret(t2, in1) == interpret(t3, in1);
     bit eq2 = interpret(t2, in2) == interpret(t3, in2);
     if(eq1 && eq2){
         assert size(t3)>= size(t2);
     }




     assert interpret(t2, t) != interpret(t3, t);
     assert size(t2)> 2;
     assert size(t3)> 2;
}
*/
