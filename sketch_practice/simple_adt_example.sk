 adt node{
      Name{ int id; }
      Num{ int val; }
      Plus {node left; node right;}
      Mod {node left; node right;}
      Div {node left; node right;}
      NotEq {node left; node right;}
      Call {int id; int n; node[n] params;}
      If { node test; node then; node else;}
      Return { node retval;}
      FunctionDef(int id; int na; node[na] args; int ns; node[ns] stmts;}
 }

 //assume FunctionDef is parsed beforehand and the info is stored in node[m] functions
 int interpret([int n], [int m], node e, int[n] assign, node[m] functions){
      switch(e){
          case Name: return assign[e.id];
          case Num: return e.val;
          case Plus: return interpret(e.left,assign,functions) + interpret(e.right,assign,functions);
          case Mod: return interpret(e.left,assign,functions) % interpret(e.right,assign,functions);

          case Div: return interpret(e.left, assign,functions) / interpret(e.right, assign,functions);
          case NotEq: return interpret(e.left, assign,functions) != interpret(e.right, assign,functions);
          case If: {
                if(interpret(e.test,assign,functions)){
                    return interpret(e.then,assign,functions);
                }
                else{
                    return interpret(e.else,assign,functions);
                }
          }
          case Return: return interpret(e.retval,assign,functions);
          case Call: {
               return interpet(functions[e.id],assign,functions);
          }
      }
      assert false;
 }




/*int size(expr e){
     switch(e){
         case Var: return 1;
         case And: return size(e.left)+ size(e.right) + 1;
         case Or: return size(e.left)+ size(e.right) + 1;
         case Not: return  size(e.left)+1;
         case Const: return 1;
     }
     return 0;
}


void foo(expr e){}

harness void main(int[10] randomness){
     expr t2 = ??(3, {});
     int idx =0;
     expr t3 = ndprog(idx, randomness);
     bit[4] in1 = ??;
     bit[4] in2 = ??;
     assert in1 != in2;
     bit eq1 = interpret(t2, in1) == interpret(t3, in1);
     bit eq2 = interpret(t2, in2) == interpret(t3, in2);
     if(eq1 && eq2){
         assert size(t3)>= size(t2);
     }




     assert interpret(t2, t) != interpret(t3, t);
     assert size(t2)> 2;
     assert size(t3)> 2;
}
*/
